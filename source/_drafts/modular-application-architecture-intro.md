---
title: 【译】模块化应用架构（一）
tags:
---
> 原文地址：https://www.goetas.com/blog/modular-application-architecture-intro/

开发软件时，一个通常要考虑的问题时软件的模块化与可扩展性。

假设我们有一个应用或者包，从外面看，它就是一个整体。仔细观察，我们可以或多或少的识别出不同的独立的组件。这些组件依赖着应用程序的其他部分，它们的开发可能需要深入了解与其依赖的相关组件。

![应用](https://www.goetas.com/img/posts/plugin-based-architecture/application.png)

随着软件的迭代，我们继续往里面加入其他组件，但这是有代价的。组件与应用程序耦合太高，并且与其他组件也存在千丝万缕的关系。如果处理不当，一个组件的小改动可能需要改变其他组件。

从个人经验来说，我个人尽量遵循[非循环依赖原则](https://en.wikipedia.org/wiki/Acyclic_dependencies_principle)

另一种允许扩展性但保持应用程序“干净”的方法是引入模块。

## 模块

模块是在应用程序之外开发的“组件”。模块只通过定义的入口点与应用程序通信。

不同的人对模块使用不同的名称作为插件，软件包，附加组件等......但主要想法始终是在应用程序之外开发的相同的独立功能。

![模块](https://www.goetas.com/img/posts/plugin-based-architecture/modules.png)


## 为什么

使用独立于应用程序的模块，有以下几个优势：
* 自定义：通过启用/禁用某些模块，改变应用程序的功能
* 减少依赖：模块独立于应用程序本身，通过接口（例如 USB）对接，两者都可以各自迭代。
* 第三方扩展：由于模块不是应用程序的一部分，只要按照对应的接口标准，第三方开发的模块，也可以完美的对接到应用程序
* 独立开发：由于应用程序和模块是独立的，所以可以是外部人员开发、独立于应用程序发布、采用与应用程序不同的技术栈
* 应用程序更小：许多功能可以通过模块实现，减轻了应用程序的负担，有更好的维护性


举个例子，来理解为什么有模块化的应用程序很重要：
* Wordpress：它是当今最流行的博客平台。其成功的一部分是一个令人难以置信的强大，同时又是令人难以置信的简单插件和主题系统
* Symfony：一个流程的 PHP 框架，由于其“捆绑”系统，可以几乎毫不费力地获得大量现成的功能
* PHP：本身提供了一套很棒的扩展，这些扩展允许将语言与各种系统集成在一起。

## 解决挑战
为了使我们的应用程序模块化，我们必须认真决定哪些模块应该能够完成，如何与应用程序通信以及如何公开其功能。在实现插件/模块化系统时，我们必须考虑模块的哪些应用行为部分将被允许更改以及采用哪种措施。

例如，如果我们正在开发一个文字处理器，一个模块可能只能添加对新文件格式的支持，或者只是在工具栏或其他地方添加一个新图标，以完全改变整个应用程序。

根据这些，我们构建的模块都不一样，但几乎总是需要处理模块结构，注册/配置，资源管理以及与内核的通信。

### 1. 模块结构

模块的结构从命名开始，如文件命名、文件夹结构、类名等。因为当模块结构变动时，对其他方面会受到很大的影响。

模块结构通常是应用程序的第一个入口点。

我个人的建议是不要强制使用任何特定的文件夹结构，而是在模块加载的地方有一个“入口点”，并使用该入口点作为事实和配置的来源。入口点”的含义将在下一段中定义。

### 2. 注册

当模块结构确定后，下一步就是让我们的应用程序知道它。

主要有两种方法可以做到这一点：

* 发现（discovery）：我们的应用程序可以尝试使用预定义的一组“规则”来查找新模块并加载/注册它们。例如，可以尝试在特定文件夹中查找某些特定文件，或者检查是否定义了特定类并尝试实例化它。

* 配置（configuration）：我们可以明确地配置应用程序来加载特定的文件或特定的类。

没有首选的方法来做到这一点，这取决于你的应用程序。如果你的受众有一定技术，“发现”方法可提供更流畅的用户体验（但可能更难以实施），那么基于“配置”的注册可能会更好。

我个人的建议是再次有一个“入口点”，将模块注册到应用程序核心，可以是单个文件，类，数据库行，服务名称等等。

应用程序提供一个或多个“接口”来与其“核心”进行交互，并通过“入口点”使用它们。这里的“接口”是指应用程序定义的任何可能的协议或约定，可能被模块用于实现目标。

![interface](https://www.goetas.com/img/posts/plugin-based-architecture/interface.png)

例如：

* composer：[composer](https://getcomposer.org/) 通过发现的方式添加功能。
Composer 将从已安装的包中的 `composer.json` 文件中，搜索有定义 `type=composer-plugin`，和名为 `class` 的属性，将注册由 class 声明的事件监听。[点击查看更多信息](https://getcomposer.org/doc/articles/plugins.md)
* symfony：[symfony](https://www.symfony.com/) 通过配置的方式添加功能。
在 `Appkernel` 类中，需要定义在 `symfony` 丰富的框架功能中需要使用的 bundles。`bundle` 类将被实例化，并负责将 bundle 注册到 symfony 允许的扩展点中。`bundle` 类能改变 symfony 本身的几乎任何部分，因为它可以访问 symfony 核心依赖注入机制。[点击查看更多信息](https://symfony.com/doc/3.4/bundles.html)。最近使用 [flex](https://github.com/symfony/flex() 时，自动发现和配置变得可用。
* laravel：[laravel](https://getcomposer.org/) 通过配发现的方式添加功能。
Laravel 将从已安装的包中的 `composer.json` 文件中，搜索属性名为 `extra.laravel` 的值，并将其注册为服务提供者。[点击查看更多信息](https://laravel.com/docs/5.5/packages)

### 3. 配置
当模块注册到内核中时，允许一些额外的配置可能会很有用。

大多数情况下，应用程序可能会以某种方式配置以符合用户期望，同样的情况也会发生在模块上。

进行配置的方式有很多种，我个人的建议是提供一个非常接近应用程序配置方式的配置机制。 如果应用程序是通过配置文件，环境变量，数据库条目或一个很好的控制面板配置的，则模块应该以相同的方式进行配置。

模块应该提供一份默认的配置（如果应用程序允许），这样不需要配置也能使用。

例如：
* composer：在 [composer](https://getcomposer.org/) 的 `composer.json` 文件中，允许您决定加载哪些插件，运行哪些命令等等
* symfony：[symfony](https://www.symfony.com/) 支持 YML、XML 和 PHP 作为配置语言，配置值可以在 `config.(yml|xml|php)`（以及其他一些地方）只声明，bundle 可以为它提供默认值
* laravel：[laravel](https://getcomposer.org/) 主要使用 PHP 为配置语言，并且在定义配置时可以使用 PHP 语言的强大功能

### 4. 资源
 某些模块可能需要向用户公开一些内容，如图像、CSS、模块、翻译、文件或类似内容。应用程序可以通过不同的方式将内容提供给用户。

 当资源是“应用程序管理”时，就是使用“应用程序接口”来提供/覆盖资源（比如使用应用程序插件接口）。

 如果资源不是由应用程序管理的，而是特定模块，则事情会变得更加复杂。处理它的一些方法是：
 * 将内容链接（linking）/复制到 Web 目录
    * 需要一些步骤来发布资源
* 使用应用程序来为资源提供服务，例如 pipe-it 
    * 可能是缓慢的或者资源密集型的
* 配置 Web 服务器以显示地提供插件资源
    * 通过添加额外配置来嘲讽模块背后的“即插即用”理念
* 让用户手动“复制和粘贴"资源

每个选项都有优缺点，最近，“链接/复制”策略最受欢迎。

### 5. 与应用程序交互

现在该模块已经加载并配置好了，一切都准备就绪。
应用程序可以决定所有的“交互”点，并检查某些模块是否对与应用程序内核交互“感兴趣”（可能）。

有许多策略与应用程序“交互”，其中一些策略限制了模块在特定的（用户自定义的）部分上交互的能力，而另一些则可能允许改变整个应用程序流程。

在接下来的文章中，我们将深入探讨与应用程序交互的方式。

## 最后
在第一篇文章中，我介绍了构建可扩展应用程序时的一些动机和挑战。在接下来的文章中，我们将看到一些与应用程序交互的策略：钩子、事件管理器、观察者模式、继承和其他方式。
